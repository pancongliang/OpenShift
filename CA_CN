1_specify_hostname_and_ip_variables.sh
#!/bin/bash
##################################################################
# OpenShift
BASE_DOMAIN="example.com"
CLUSTER_NAME="ocp4"
API_HOSTNAME="api.ocp4.example.com"
API_INT_HOSTNAME="api-int.ocp4.example.com"
APPS_HOSTNAME="*.apps.ocp4.example.com"
OCP_RELEASE="4.10.20"
NETWORK_TYPE="OVNKubernetes"    # OVNKubernetes / OpenShiftSDN
ID_RSA_PUB="/root/.ssh/id_rsa.pub"
INSTALL_DIR="$INSTALL_DIR"

# REGISTRY
REGISTRY_HOSTNAME="docker.registry.example.com"
REGISTRY_ID="admin"
REGISTRY_PW="redhat"
LOCAL_SECRET_JSON='/root/pull-secret'

# Nde hostnames
BASTION_HOSTNAME="bastion.ocp4.example.com"
MASTER01_HOSTNAME="master01.ocp4.example.com"
MASTER02_HOSTNAME="master02.ocp4.example.com"
MASTER03_HOSTNAME="master03.ocp4.example.com"
WORKER01_HOSTNAME="worker01.ocp4.example.com"
WORKER02_HOSTNAME="worker02.ocp4.example.com"
BOOTSTRAP_HOSTNAME="bootstrap.ocp4.example.com"

# IP addresses
API_IP="10.74.251.171"
API_INT_IP="10.74.251.171"
APPS_IP="10.74.251.171"
BASTION_IP="10.74.251.171"
REGISTRY_IP="10.74.251.171"
GATEWAY_IP="21"
NETMASK="10.74.255.254"
DNS_IP="10.74.251.171"
DNS_FORWARDER_IP="10.75.5.25"
MASTER01_IP="10.74.251.61"
MASTER02_IP="10.74.254.155"
MASTER03_IP="10.74.253.133"
WORKER01_IP="10.74.251.58"
WORKER02_IP="10.74.253.49"
BOOTSTRAP_IP="10.74.255.118"


# REVERSE_ZONE
REVERSE_ZONE="74.10.in-addr.arpa"
REVERSE_ZONE_FILE_NAME="74.10.zone"
##################################################################
sudo sleep 1

# Function to generate reversed DNS
generate_reverse_dns() {
  local ip="$1"
  reversed_dns=$(echo "$ip" | awk -F'.' '{print $4"."$3}')
  echo "$reversed_dns"
}
sudo sleep 1

# Generate reversed DNS for each IP and store as variables
BASTION_REVERSE_DNS=$(generate_reverse_dns "$BASTION_IP")
REGISTRY_REVERSE_DNS=$(generate_reverse_dns "$REGISTRY_IP")
MASTER01_REVERSE_DNS=$(generate_reverse_dns "$MASTER01_IP")
MASTER02_REVERSE_DNS=$(generate_reverse_dns "$MASTER02_IP")
MASTER03_REVERSE_DNS=$(generate_reverse_dns "$MASTER03_IP")
WORKER01_REVERSE_DNS=$(generate_reverse_dns "$WORKER01_IP")
WORKER02_REVERSE_DNS=$(generate_reverse_dns "$WORKER02_IP")
BOOTSTRAP_REVERSE_DNS=$(generate_reverse_dns "$BOOTSTRAP_IP")
API_REVERSE_DNS=$(generate_reverse_dns "$API_IP")
API_INT_REVERSE_DNS=$(generate_reverse_dns "$API_INT_IP")

# Store the variables in a file
echo "DNS_FORWARDER_IP=$DNS_FORWARDER_IP" > generated_vars.sh
echo "REVERSE_ZONE=$REVERSE_ZONE" >> generated_vars.sh
echo "REVERSE_ZONE_FILE_NAME=$REVERSE_ZONE_FILE_NAME" >> generated_vars.sh
echo "REGISTRY_ID=$REGISTRY_ID" >> generated_vars.sh
echo "REGISTRY_PW=$REGISTRY_PW" >> generated_vars.sh
echo "LOCAL_SECRET_JSON=$LOCAL_SECRET_JSON" >> generated_vars.sh
echo "INSTALL_DIR=$INSTALL_DIR" >> generated_vars.sh
echo "ID_RSA_PUB=$ID_RSA_PUB" >> generated_vars.sh
echo "OCP_RELEASE=$OCP_RELEASE" >> generated_vars.sh
echo "CLUSTER_NAME=$CLUSTER_NAME" >> generated_vars.sh
echo "GATEWAY_IP=$GATEWAY_IP" >> generated_vars.sh
echo "NETMASK=$NETMASK" >> generated_vars.sh
echo "DNS_IP=$DNS_IP" >> generated_vars.sh

echo "LOCAL_REPOSITORY=ocp4/openshift4" >> generated_vars.sh
echo "PRODUCT_REPO=openshift-release-dev" >> generated_vars.sh
echo "RELEASE_NAME=ocp-release" >> generated_vars.sh
echo "ARCHITECTURE=x86_64" >> generated_vars.sh

echo "BASTION_REVERSE_DNS=$BASTION_REVERSE_DNS" >> generated_vars.sh
echo "REGISTRY_REVERSE_DNS=$REGISTRY_REVERSE_DNS" >> generated_vars.sh
echo "MASTER01_REVERSE_DNS=$MASTER01_REVERSE_DNS" >> generated_vars.sh
echo "MASTER02_REVERSE_DNS=$MASTER02_REVERSE_DNS" >> generated_vars.sh
echo "MASTER03_REVERSE_DNS=$MASTER03_REVERSE_DNS" >> generated_vars.sh
echo "WORKER01_REVERSE_DNS=$WORKER01_REVERSE_DNS" >> generated_vars.sh
echo "WORKER02_REVERSE_DNS=$WORKER02_REVERSE_DNS" >> generated_vars.sh
echo "BOOTSTRAP_REVERSE_DNS=$BOOTSTRAP_REVERSE_DNS" >> generated_vars.sh
echo "API_REVERSE_DNS=$API_REVERSE_DNS" >> generated_vars.sh
echo "API_INT_REVERSE_DNS=$API_INT_REVERSE_DNS" >> generated_vars.sh

echo "BASTION_HOSTNAME=$BASTION_HOSTNAME" >> generated_vars.sh
echo "REGISTRY_HOSTNAME=$REGISTRY_HOSTNAME" >> generated_vars.sh
echo "MASTER01_HOSTNAME=$MASTER01_HOSTNAME" >> generated_vars.sh
echo "MASTER02_HOSTNAME=$MASTER02_HOSTNAME" >> generated_vars.sh
echo "MASTER03_HOSTNAME=$MASTER03_HOSTNAME" >> generated_vars.sh
echo "WORKER01_HOSTNAME=$WORKER01_HOSTNAME" >> generated_vars.sh
echo "WORKER02_HOSTNAME=$WORKER02_HOSTNAME" >> generated_vars.sh
echo "BOOTSTRAP_HOSTNAME=$BOOTSTRAP_HOSTNAME" >> generated_vars.sh
echo "API_HOSTNAME=$API_HOSTNAME" >> generated_vars.sh
echo "API_INT_HOSTNAME=$API_INT_HOSTNAME" >> generated_vars.sh
echo "APPS_HOSTNAME=$APPS_HOSTNAME" >> generated_vars.sh
echo "BASE_DOMAIN=$BASE_DOMAIN" >> generated_vars.sh

sudo sleep 1
# Load additional scripts
source /root/test/generated_vars.sh

2_install_rpm_ocp_tool_and_disable_selinux_firewalld_reboot.sh
# Install required packages
yum install -y wget net-tools podman bind-utils bind haproxy git bash-completion vim jq nfs-utils httpd httpd-tools skopeo httpd-manual

# openshift-install:
wget https://mirror.openshift.com/pub/openshift-v4/clients/ocp/$OCP_RELEASE/openshift-install-linux.tar.gz
tar xvf openshift-install-linux.tar.gz
mv openshift-install /usr/local/bin/

# oc CLI tools:
curl https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/stable/openshift-client-linux.tar.gz --output openshift-client-linux.tar.gz
tar xvf openshift-client-linux.tar.gz
mv oc kubectl /usr/local/bin/

# oc-mirror tools:
curl -O https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/stable/oc-mirror.tar.gz
tar -xvf oc-mirror.tar.gz
chmod +x oc-mirror && mv oc-mirror /usr/local/bin/

# butane tools:
curl https://mirror.openshift.com/pub/openshift-v4/clients/butane/latest/butane --output butane
chmod a+x butane && mv butane /usr/local/bin/

ls /usr/local/bin/

# Disable firewalld
systemctl disable firewalld

# Disable SELinux
sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config

# Reboot the system
reboot
~~~

3_Set_httpd_named_haproxy_registry.sh
#!/bin/bash

# Update httpd configuration
sed -i 's/Listen 80/Listen 8080/' /etc/httpd/conf/httpd.conf

# Create base.conf for VirtualHost
cat << EOF > /etc/httpd/conf.d/base.conf
<VirtualHost *:8080>
   ServerName bastion
   DocumentRoot /var/www/html/materials/
</VirtualHost>
EOF

# Enable and start httpd
systemctl enable httpd --now

# Apply named.conf configuration
cat << EOF > /etc/named.conf
options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        secroots-file   "/var/named/data/named.secroots";
        recursing-file  "/var/named/data/named.recursing";
        allow-query     { any; };
        forwarders      { $DNS_FORWARDER_IP; };

        /* 
         - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion.
         - If you are building a RECURSIVE (caching) DNS server, you need to enable 
           recursion. 
         - If your recursive DNS server has a public IP address, you MUST enable access 
           control to limit queries to your legitimate users. Failing to do so will
           cause your server to become part of large scale DNS amplification 
           attacks. Implementing BCP38 within your network would greatly
           reduce such attack surface 
        */
        recursion yes;
        # mod
        # allow-query-cache { none; };
        #recursion no;
        # mod

        dnssec-enable yes;
        dnssec-validation yes;

        managed-keys-directory "/var/named/dynamic";

        pid-file "/run/named/named.pid";
        session-keyfile "/run/named/session.key";

        /* https://fedoraproject.org/wiki/Changes/CryptoPolicy */
        //include "/etc/crypto-policies/back-ends/bind.config";
};

zone "$BASE_DOMAIN" IN {
        type master;
        file "$BASE_DOMAIN.zone";
        allow-query { any; };
};

zone "$REVERSE_ZONE" IN {
        type master;
        file "$REVERSE_ZONE_FILE_NAME";
        allow-query { any; };
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
        type hint;
        file "named.ca";
};

include "/etc/named.rfc1912.zones";
//include "/etc/named.root.key";
EOF

# Add DNS A/AAAA record
cat << EOF >  /var/named/$BASE_DOMAIN.zone
\$TTL 1W
@       IN      SOA     ns1.$BASE_DOMAIN.        root (
                        201907070      ; serial
                        3H              ; refresh (3 hours)
                        30M             ; retry (30 minutes)
                        2W              ; expiry (2 weeks)
                        1W )            ; minimum (1 week)
        IN      NS      ns1.$BASE_DOMAIN.
;
;
ns1     IN      A       $BASTION_IP
;
helper  IN      A       $BASTION_IP
helper.ocp4     IN      A       $BASTION_IP
;
; The api identifies the IP of your load balancer.
$API_HOSTNAME.                  IN      A       $API_IP
$API_INT_HOSTNAME.              IN      A       $API_INT_IP
;
; The wildcard also identifies the load balancer.
$APPS_HOSTNAME.                 IN      A       $APPS_IP
;
; Create entries for the master hosts.
$MASTER01_HOSTNAME.             IN      A       $MASTER01_IP
$MASTER02_HOSTNAME.             IN      A       $MASTER02_IP
$MASTER03_HOSTNAME.             IN      A       $MASTER03_IP
;
; Create entries for the worker hosts.
$WORKER01_HOSTNAME.             IN      A       $WORKER01_IP
$WORKER02_HOSTNAME.             IN      A       $WORKER02_IP
;
; Create an entry for the bootstrap host.
$BOOTSTRAP_HOSTNAME.            IN      A       $BOOTSTRAP_IP
;
; Create entries for the mirror registry hosts.
$REGISTRY_HOSTNAME.             IN      A       $REGISTRY_IP
EOF

# Add DNS PTR record
cat << EOF >  /var/named/$REVERSE_ZONE
\$TTL 1W
@       IN      SOA     ns1.$BASE_DOMAIN.        root (
                        2019070700      ; serial
                        3H              ; refresh (3 hours)
                        30M             ; retry (30 minutes)
                        2W              ; expiry (2 weeks)
                        1W )            ; minimum (1 week)
        IN      NS      ns1.$BASE_DOMAIN.
;
; The syntax is "last octet" and the host must have an FQDN
; with a trailing dot.
;
; The api identifies the IP of your load balancer.
$API_REVERSE_DNS                IN      PTR     $API_HOSTNAME.
$API_INT_REVERSE_DNS            IN      PTR     $API_INT_HOSTNAM
;
; Create entries for the master hosts.
$MASTER01_REVERSE_DNS           IN      PTR     $MASTER01_HOSTNAME.
$MASTER02_REVERSE_DNS           IN      PTR     $MASTER02_HOSTNAME.
$MASTER03_REVERSE_DNS           IN      PTR     $MASTER02_HOSTNAME.
;
; Create entries for the worker hosts.
$WORKER01_REVERSE_DNS           IN      PTR     $WORKER01_HOSTNAME.
$WORKER02_REVERSE_DNS           IN      PTR     $WORKER02_HOSTNAME.
EOF

# Restart DNS
chown named. /var/named/*.zone
systemctl enable named --now
sudo sleep 5
echo "nameserver $BASTION_IP" > /etc/resolv.conf

# Set haproxy_cfg
cat << EOF > /etc/haproxy/haproxy.cfg 
global
  log         127.0.0.1 local2
  pidfile     /var/run/haproxy.pid
  maxconn     4000
  daemon

defaults
  mode                    http
  log                     global
  option                  dontlognull
  option http-server-close
  option                  redispatch
  retries                 3
  timeout http-request    10s
  timeout queue           1m
  timeout connect         10s
  timeout client          1m
  timeout server          1m
  timeout http-keep-alive 10s
  timeout check           10s
  maxconn                 3000

frontend stats
  bind *:1936
  mode            http
  log             global
  maxconn 10
  stats enable
  stats hide-version
  stats refresh 30s
  stats show-node
  stats show-desc Stats for ocp4 cluster 
  stats auth admin:passwd
  stats uri /stats

listen api-server-6443 
  bind $BASTION_IP:6443
  mode tcp
  server     $BOOTSTRAP_HOSTNAME $BOOTSTRAP_IP:6443 check inter 1s backup
  server     $MASTER01_HOSTNAME $MASTER01_IP:6443 check inter 1s
  server     $MASTER02_HOSTNAME $MASTER02_IP:6443 check inter 1s
  server     $MASTER03_HOSTNAME $MASTER03_IP:6443 check inter 1s

listen machine-config-server-22623 
  bind $BASTION_IP:22623
  mode tcp
  server     $BOOTSTRAP_HOSTNAME 10.74.255.118:22623 check inter 1s backup
  server     $MASTER01_HOSTNAME $MASTER01_IP:22623 check inter 1s
  server     $MASTER02_HOSTNAME $MASTER02_IP:22623 check inter 1s
  server     $MASTER03_HOSTNAME $MASTER03_IP:22623 check inter 1s

listen default-ingress-router-80
  bind $BASTION_IP:80
  mode tcp
  balance source
  server     $WORKER01_HOSTNAME $WORKER01_IP:80 check inter 1s
  server     $WORKER02_HOSTNAME $WORKER02_IP:80 check inter 1s

listen default-ingress-router-443
  bind $BASTION_IP:443
  mode tcp
  balance source
  server     $WORKER01_HOSTNAME $WORKER01_IP:443 check inter 1s
  server     $WORKER02_HOSTNAME $WORKER02_IP:443 check inter 1s
EOF

# Start haproxy:
$ systemctl enable haproxy --now

# Self_signed_cert_and_create_registry.sh
# Create registry directory:
mkdir -p /opt/registry/{auth,certs,data}
mkdir -p /etc/crts/ && cd /etc/crts/

# Generate root ca.key:
openssl genrsa -out /etc/crts/${REGISTRY_HOSTNAM}.ca.key 4096

# Generate root ca.crt:
openssl req -x509 \
  -new -nodes \
  -key /etc/crts/${REGISTRY_HOSTNAM}.ca.key \
  -sha256 \
  -days 36500 \
  -out /etc/crts/${REGISTRY_HOSTNAM}.ca.crt \
  -subj /CN=Local Red Hat Signer \
  -reqexts SAN \
  -extensions SAN \
  -config <(cat /etc/pki/tls/openssl.cnf \
      <(printf '[SAN]\nbasicConstraints=critical, CA:TRUE\nkeyUsage=keyCertSign, cRLSign, digitalSignature'))

# Generate domain key:
openssl genrsa -out ${REGISTRY_HOSTNAM}.key 2048

# Generate domain cert csr:
openssl req -new -sha256 \
    -key /etc/crts/${REGISTRY_HOSTNAM}.key \
    -subj "/O=Local Red Hat CodeReady Workspaces/CN=${REGISTRY_HOSTNAM}" \
    -reqexts SAN \
    -config <(cat /etc/pki/tls/openssl.cnf \
        <(printf "\n[SAN]\nsubjectAltName=DNS:${REGISTRY_HOSTNAM}\nbasicConstraints=critical, CA:FALSE\nkeyUsage=digitalSignature, keyEncipherment, keyAgreement, dataEncipherment\nextendedKeyUsage=serverAuth")) \
    -out /etc/crts/${REGISTRY_HOSTNAM}.csr

# Generate domain crt:
openssl x509 \
    -req \
    -sha256 \
    -extfile <(printf "subjectAltName=DNS:${REGISTRY_HOSTNAM}\nbasicConstraints=critical, CA:FALSE\nkeyUsage=digitalSignature, keyEncipherment, keyAgreement, dataEncipherment\nextendedKeyUsage=serverAuth") \
    -days 365 \
    -in /etc/crts/${REGISTRY_HOSTNAM}.csr \
    -CA /etc/crts/${REGISTRY_HOSTNAM}.ca.crt \
    -CAkey /etc/crts/${REGISTRY_HOSTNAM}.ca.key \
    -CAcreateserial -out /etc/crts/${REGISTRY_HOSTNAM}.crt
    
openssl x509 -in /etc/crts/${REGISTRY_HOSTNAM}.ca.crt -text

# Copy and trust the cert:
cp /etc/crts/${REGISTRY_HOSTNAM}.ca.crt ${REGISTRY_HOSTNAM}.crt /etc/pki/ca-trust/source/anchors/
update-ca-trust extract
cp /etc/crts/${REGISTRY_HOSTNAM}.key ${REGISTRY_HOSTNAM}.crt /opt/registry/certs/
update-ca-trust

# Create username and password for offline mirror repository:
htpasswd -bBc /opt/registry/auth/htpasswd $REGISTRY_ID $REGISTRY_PW

# Running docker registry:
podman run \
    --name mirror-registry \
    -p 5000:5000 \
    -e "REGISTRY_AUTH=htpasswd" \
    -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \
    -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \
    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/${REGISTRY_HOSTNAM}.crt \
    -e REGISTRY_HTTP_TLS_KEY=/certs/${REGISTRY_HOSTNAM}.key \
    -e REGISTRY_STORAGE_DELETE_ENABLED=true \
    -v /opt/registry/data:/var/lib/registry:z \
    -v /opt/registry/auth:/auth:z \
    -v /opt/registry/certs:/certs:z \
    -d docker.io/library/registry:2

sudo sleep 120

podman login -u $REGISTRY_ID -p $REGISTRY_PW ${REGISTRY_HOSTNAM}:5000

# Automatically start docker registry:
cat << EOF > /etc/systemd/system/mirror-registry.service
[Unit]
Description= registry service
After=network.target
After=network-online.target
[Service]
Restart=always
ExecStart=/usr/bin/podman start -a mirror-registry
ExecStop=/usr/bin/podman stop -t 10 mirror-registry
[Install]
WantedBy=multi-user.target
EOF

systemctl enable mirror-registry.service --now
podman login -u $REGISTRY_ID -p $REGISTRY_PW --authfile /root/pull-secret {REGISTRY_HOSTNAM}:5000 
curl -u $REGISTRY_ID:$REGISTRY_PW -k https://${REGISTRY_HOSTNAM}:5000/v2/_catalog


4_download_image.sh
#!/bin/bash

$ oc adm -a ${LOCAL_SECRET_JSON} release mirror \
  --from=quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE} \
  --to=${LREGISTRY_HOSTNAM}:5000/${LOCAL_REPOSITORY} \
  --to-release-image=${LREGISTRY_HOSTNAM}:5000/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE} 

5_create_install_config.sh:**
#!/bin/bash
cp /etc/crts/${REGISTRY_HOSTNAME}.ca.crt /etc/crts/${REGISTRY_HOSTNAME}.bk.ca.crt
sed -i 's/^/  /' /etc/crts/${REGISTRY_HOSTNAME}.bk.ca.crt
export REGISTRY_CA="$(cat /etc/crts/${REGISTRY_HOSTNAME}.bk.ca.crt)"
export REGISTRY_ID_PW=$(echo -n "$REGISTRY_ID:$REGISTRY_PW" | base64)
export ID_RSA_PUB=$(cat $ID_RSA_PUB)

cat << EOF > /root/test/install-config.yaml 
apiVersion: v1
baseDomain: $BASE_DOMAIN
compute: 
- hyperthreading: Enabled 
  name: worker
  replicas: 0 
controlPlane: 
  hyperthreading: Enabled 
  name: master
  replicas: 3 
metadata:
  name: $CLUSTER_NAME
networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14 
    hostPrefix: 23 
  networkType: $NETWORK_TYPE
  serviceNetwork: 
  - 172.30.0.0/16
platform:
  none: {} 
fips: false 
pullSecret: '{"auths":{"${REGISTRY_HOSTNAME}:5000": {"auth": "$REGISTRY_ID_PW","email": "xxx@xxx.com"}}}' 
sshKey: '$ID_RSA_PUB'
additionalTrustBundle: | 
$REGISTRY_CA
imageContentSources:
- mirrors:
  - ${REGISTRY_HOSTNAME}:5000/${LOCAL_REPOSITORY}
  source: quay.io/openshift-release-dev/ocp-release
- mirrors:
  - ${REGISTRY_HOSTNAME}:5000/${LOCAL_REPOSITORY}
  source: quay.io/openshift-release-dev/ocp-v4.0-art-dev
EOF

# Create kubernetes manifests:**
mkdir $INSTALL_DIR
cp install-config.yaml $INSTALL_DIR
openshift-install create manifests --dir $INSTALL_DIR
sed -i 's/mastersSchedulable: true/mastersSchedulable: false/' $INSTALL_DIR/manifests/cluster-scheduler-02-config.yml

# Create and modify ignition configuration files
openshift-install create ignition-configs --dir $INSTALL_DIR
cp $INSTALL_DIR/bootstrap.ign $INSTALL_DIR/bootstrapbk.ign
for i in {01..03}; do cp $INSTALL_DIR/master.ign $INSTALL_DIR/master$i.ign; done
for i in {01..02}; do cp $INSTALL_DIR/worker.ign $INSTALL_DIR/worker$i.ign; done
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,bootstrap.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/bootstrapbk.ign
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,master01.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/master01.ign
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,master02.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/master02.ign
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,master03.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/master03.ign
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,worker01.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/worker01.ign
sed -i 's/}$/,"storage":{"files":[{"path":"\/etc\/hostname","contents":{"source":"data:,worker02.ocp4.example.com"},"mode": 420}]}}/' $INSTALL_DIR/worker02.ign
chmod a+r $INSTALL_DIR/*.ign


5_set_bootstrap_master_worker_ignition_ip.sh
# bootstrap-set-ip-1.sh
cat << EOF > $INSTALL_DIR/bootstrap-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $BOOTSTRAP_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
sudo sleep 10
EOF

# master01-set-ip-1.sh
cat << EOF > $INSTALL_DIR/master01-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $MASTER01_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
EOF

# master02-set-ip-1.sh
cat << EOF > $INSTALL_DIR/master02-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $MASTER02_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
EOF

# master03-set-ip-1.sh
cat << EOF > $INSTALL_DIR/master03-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $MASTER03_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
EOF

# worker01-set-ip-1.sh
cat << EOF > $INSTALL_DIR/master02-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $WORKER01_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
EOF

# worker02-set-ip-2.sh
cat << EOF > $INSTALL_DIR/worker02-set-ip-1.sh
nmcli con mod 'Wired connection 1' ipv4.addresses $WORKER02_IP/$NETMASK ipv4.gateway 10.74.255.254 ipv4.dns $DNS_IP ipv4.method manual connection.autoconnect yes
sudo systemctl restart NetworkManager
EOF

cat << EOF > $INSTALL_DIR/bootstrap-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/bootstrapbk.ign /dev/sda \
     --insecure-ignition
EOF

cat << EOF > $INSTALL_DIR/master01-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/master01.ign /dev/sda \
     --insecure-ignition
EOF

cat << EOF > $INSTALL_DIR/master02-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/master02.ign /dev/sda \
     --insecure-ignition
EOF

cat << EOF > $INSTALL_DIR/master03-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/master03.ign /dev/sda \
     --insecure-ignition
EOF

cat << EOF > $INSTALL_DIR/worker01-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/worker01.ign /dev/sda \
     --insecure-ignition
EOF

cat << EOF > $INSTALL_DIR/worker02-installer-2.sh
sudo coreos-installer install --copy-network \
     --ignition-url=http://$BASTION_IP:8080/pre/worker02.ign /dev/sda \
     --insecure-ignition
EOF

- node(bootstrap/master/worker)
~~~
$ sudo -i
$ curl http://$BASTION_IP:8080/bootstrap-set-ip-1.sh | bash
$ curl http://$BASTION_IP:8080/master01-set-ip-1.sh | bash
$ curl http://$BASTION_IP:8080/master02-set-ip-1.sh | bash
$ curl http://$BASTION_IP:8080/master03-set-ip-1.sh | bash
$ curl http://$BASTION_IP:8080/worker01-set-ip-1.sh | bash
$ curl http://$BASTION_IP:8080/worker02-set-ip-1.sh | bash

$ curl http://$BASTION_IP:8080/bootstrap-installer-2.sh | bash
$ curl http://$BASTION_IP:8080/master01-installer-2.sh | bash
$ curl http://$BASTION_IP:8080/master02-installer-2.sh | bash
$ curl http://$BASTION_IP:8080/master03-installer-2.sh | bash
$ curl http://$BASTION_IP:8080/worker01-installer-2.sh | bash
$ curl http://$BASTION_IP:8080/worker02-installer-2.sh | bash


- After the restart is complete, access the bootstrap node:
$ ssh core@bootstrap.ocp4.example.com
$ sudo -i

- Check if it is normal or not:
$ netstat -ntplu |grep 6443
$ netstat -ntplu |grep 22623
$ podman ps
$ journalctl -b -f -u release-image.service -u bootkube.service
~~~

d. Check if master is installed:
~~~
$ ssh core@bootstrap.ocp4.example.com
$ sudo -i
$ journalctl -b -f -u bootkube.service
···Wait···
bootkube.service complete    #
bootkube.service: Succeeded  #<--Show this content to complete the master installation.
~~~

e. Install worker 01 - 02:
~~~
$ coreos.inst.install_dev=sda coreos.inst.ignition_url=http://$BASTION_IP:8080/pre/worker.ign  
ip=10.74.251.58::10.74.255.254:255.255.248.0:worker01.ocp4.example.com:ens3:none
nameserver=$BASTION_IP nameserver=10.74.251.204

$ coreos.inst.install_dev=sda coreos.inst.ignition_url=http://$BASTION_IP:8080/pre/worker.ign  
ip=10.74.249.234::10.74.255.254:255.255.248.0:worker02.ocp4.example.com:ens3:none
nameserver=$BASTION_IP nameserver=10.74.251.204

- Wait for the reboot to complete:
~~~

**2.6 login ocp:**
~~~
- kubeconfig login:
$ echo export KUBECONFIG=$INSTALL_DIR/auth/kubeconfig >> /root/.bash_profile
$ echo export LANG=“en_US.UTF-8” >> ~/.bash_profile
$ source ~/.bash_profile

- completion command:
$ oc completion bash >> /etc/bash_completion.d/oc_completion
$ oc whoami
system:admin

$ source ~/.bash_profile
~~~


a.Setup NFS:
~~~
$ mkdir /nfs
$ mkdir /nfs/image-registry
$ useradd nfsnobody
$ chown -R nfsnobody.nfsnobody /nfs
$ chmod -R 777 /nfs
echo '/nfs    **(rw,sync,no_wdelay,no_root_squash,insecure,fsid=0)' >> /etc/exports
$ systemctl enable nfs-server --now
~~~

b.Create PV:
~~~
cat << EOF | oc apply -f -
apiVersion: v1
kind: PersistentVolume
metadata:
  name: image-registry
spec:
  capacity:
    storage: 100Gi
  accessModes:
  - ReadWriteMany
  nfs:
    path: /nfs/image-registry
    server: $BASTION_IP
  persistentVolumeReclaimPolicy: Retain
EOF
~~~

c.Modify image-registry operator:
~~~
$ oc patch configs.imageregistry.operator.openshift.io cluster --type merge --patch '{"spec":{"managementState":"Managed"}}'
$ oc patch configs.imageregistry.operator.openshift.io/cluster --type merge --patch '{"spec":{"storage":{"pvc":{"claim":""}}}}'
~~~

**2.10 Trust the docker repository:**

a.Create configmap:
~~~
$ oc create configmap registry-cas \
     --from-file=docker.registry.example.com..5000=/etc/pki/ca-trust/source/anchors/docker.registry.example.com.ca.crt \
     -n openshift-config
~~~
b.Trust repository
~~~
$ oc patch image.config.openshift.io/cluster --patch '{"spec":{"additionalTrustedCA":{"name":"registry-cas"}}}' --type=merge
~~~

**2.11 Set “samples operator” to specify the docker registry:**
~~~
$ oc patch configs.samples.operator.openshift.io cluster --patch '[{"op": "replace", "path": "/spec/managementState", "value":"Removed"}]' --type=json

$ oc patch configs.samples.operator.openshift.io cluster --patch '{"spec":{"samplesRegistry":null,"skippedImagestreams":null}}' --type=merge

$ oc patch configs.samples.operator.openshift.io cluster --patch '[{"op": "replace", "path": "/spec/managementState", "value":"Managed"}]' --type=json

$ oc patch configs.samples.operator.openshift.io cluster --patch '{"spec":{"samplesRegistry":"docker.registry.example.com:5000","skippedImagestreams":["jenkins","jenkins-agent-nodejs","jenkins-agent-maven"]}}' --type=merge
~~~
